#version 430

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0) uniform atomic_uint fragListSize;

layout (binding = 0, r32ui) readonly uniform uimage2D voxelFragList;
layout (binding = 1, r32ui) uniform uimage3D voxelPackedData;
layout (binding = 2, rgba16) writeonly uniform image3D voxelRadiance;

##import lib/util
##import voxel_shared

void main()
{
	uint index = gl_WorkGroupID.x * (gl_WorkGroupSize.x * gl_WorkGroupSize.y) + gl_LocalInvocationIndex;
	uint size = atomicCounter(fragListSize);
	if (index >= size) return;

	uint packedPosition = imageLoad(voxelFragList, ivec2(index & MaxFragListMask[0], index >> FragListWidthBits[0])).r;
	ivec3 position = ivec3(
		(packedPosition >> 20) & 0x3FF,
		(packedPosition >> 10) & 0x3FF,
		packedPosition & 0x3FF
	);

	ivec3 dataOffset = position * ivec3(3, 1, 1);

	vec3 radiance;
	radiance.r = float(imageLoad(voxelPackedData, dataOffset + ivec3(0, 0, 0)).r) / 0xFFFF;
	radiance.g = float(imageLoad(voxelPackedData, dataOffset + ivec3(1, 0, 0)).r) / 0xFFFF;

	uint data = imageLoad(voxelPackedData, dataOffset + ivec3(2, 0, 0)).r;
	radiance.b = float((data & 0xFFFFFF00) >> 8) / 0xFFFF;
	float count = float(data & 0xFF);

	imageStore(voxelRadiance, position, vec4(radiance / count, 1.0));

	imageStore(voxelPackedData, dataOffset + ivec3(0, 0, 0), uvec4(0));
	imageStore(voxelPackedData, dataOffset + ivec3(1, 0, 0), uvec4(0));
	imageStore(voxelPackedData, dataOffset + ivec3(2, 0, 0), uvec4(0));
}