#version 430

##import lib/types_common

layout (local_size_x = MAX_LIGHTS, local_size_y = MAX_MIRRORS) in;

##import lib/mirror_common

uniform int lightCount = 0;
uniform int mirrorCount = 0;

layout(binding = 0, std140) uniform GLLightData {
	Light lights[MAX_LIGHTS];
};

layout(binding = 1, std140) uniform GLMirrorData {
	Mirror mirrors[MAX_MIRRORS];
};

mat4 makeProjectionMatrix(vec3 viewSpaceMirrorPos, vec2 clip, vec2 size, vec4 bounds) {
	return mat4(
		2*clip.x/size.x,            0,                          0,                                0,
		0,                          2*clip.x/size.y,            0,                                0,
		(bounds.y+bounds.x)/size.x, (bounds.z+bounds.w)/size.y, -(clip.y+clip.x)/(clip.y-clip.x), -1,
		0,                          0,                          -2*clip.y*clip.x/(clip.y-clip.x), 0
	);
}

void main() {
	uint index = gl_LocalInvocationIndex;
	if (index >= mirrorData.count) return;

	uint lightId = (mirrorData.list[index] >> 16) & 0xFFFF;
	uint mirrorId = mirrorData.list[index] & 0xFFFF;

	vec3 mirrorNormal = mat3(mirrors[mirrorId].modelMat) * vec3(0, 0, -1);
	vec3 mirrorPos = vec3(mirrors[mirrorId].modelMat * vec4(0, 0, 0, 1));

	mat3 reflectionMat = mat3(1) - 2 * outerProduct(mirrorNormal, mirrorNormal);
	vec3 focalPoint = reflectionMat * (lights[lightId].position - mirrorPos);

	mat4 mirrorViewMat = inverse(mirrors[mirrorId].modelMat);
	mat4 translation = mat4(1);
	translation[3] = vec4(-focalPoint, 1.0);
	mirrorViewMat = mirrorViewMat * translation;

	vec3 viewSpaceMirrorPos = vec3(mirrorViewMat * vec4(mirrorPos, 1.0));
	vec2 clip = vec2(-viewSpaceMirrorPos.z, 64);
	vec2 size = mirrors[mirrorId].size;
	vec4 bounds = viewSpaceMirrorPos.xxyy + vec4(-size.x, size.x, -size.y, size.y) * 0.5;

	mirrorData.viewMat[index] = mirrorViewMat;
	mirrorData.projMat[index] = makeProjectionMatrix(viewSpaceMirrorPos, clip, size, bounds);
	mirrorData.invViewMat[index] = inverse(mirrorData.viewMat[index]);
	mirrorData.invProjMat[index] = inverse(mirrorData.projMat[index]);
	mirrorData.clip[index] = clip;
	mirrorData.nearInfo[index] = vec4(bounds.xz, size);
}