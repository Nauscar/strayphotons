#version 430

##import lib/types_common
##import lib/mirror_shadow_common

layout (local_size_x = MAX_LIGHTS, local_size_y = MAX_MIRRORS) in;

uniform int lightCount = 0;
uniform int mirrorCount = 0;

layout(binding = 0, std140) uniform GLLightData {
	Light lights[MAX_LIGHTS];
};

layout(binding = 1, std140) uniform GLMirrorData {
	Mirror mirrors[MAX_MIRRORS];
};

mat4 makeProjectionMatrix(vec3 viewSpaceMirrorPos, vec2 clip, vec2 size, vec4 bounds) {
	return mat4(
		2*clip.x/size.x,            0,                          0,                                0,
		0,                          2*clip.x/size.y,            0,                                0,
		(bounds.y+bounds.x)/size.x, (bounds.z+bounds.w)/size.y, -(clip.y+clip.x)/(clip.y-clip.x), -1,
		0,                          0,                          -2*clip.y*clip.x/(clip.y-clip.x), 0
	);
}

void main() {
	if (gl_LocalInvocationIndex == 0) {
		mirrorData.count[1] = mirrorData.count[2];
		mirrorData.count[2] = mirrorData.count[0];
	}

	barrier();

	if (gl_LocalInvocationIndex == 0) {
		for (int i = 0; i < MAX_LIGHTS; i++)
			mirrorData.maskL[i] = 0;
		for (int i = 0; i < MAX_MIRRORS; i++)
			mirrorData.maskM[i] = 0;
	}

	uint index = gl_LocalInvocationIndex + mirrorData.count[1];
	if (index >= mirrorData.count[0]) return;

	uint tuple = mirrorData.list[index];
	int sourceId = UnpackMirrorSource(tuple);
	int mirrorId = UnpackMirrorDest(tuple);

	vec3 mirrorNormal = mat3(mirrors[mirrorId].modelMat) * vec3(0, 0, -1);
	vec3 mirrorPos = vec3(mirrors[mirrorId].modelMat * vec4(0, 0, 0, 1));

	vec3 sourcePos, lightDir;

	if (MirrorSourceIsMirror(tuple)) {
		int sourceIndex = mirrorData.sourceIndex[index];
		sourcePos = vec3(mirrorData.invViewMat[sourceIndex] * vec4(0, 0, 0, 1));
		lightDir = reflect(mirrorData.lightDirection[sourceIndex], mirrorNormal);
	} else {
		sourcePos = lights[sourceId].position;
		lightDir = reflect(lights[sourceId].direction, mirrorNormal);
	}

	mat3 reflectionMat = mat3(1) - 2 * outerProduct(mirrorNormal, mirrorNormal);
	vec3 focalPoint = reflectionMat * (sourcePos - mirrorPos);

	mat4 mirrorViewMat = inverse(mirrors[mirrorId].modelMat);
	mat4 translation = mat4(1);
	translation[3] = vec4(-focalPoint, 1.0);
	mirrorViewMat = mirrorViewMat * translation;

	vec3 viewSpaceMirrorPos = vec3(mirrorViewMat * vec4(mirrorPos, 1.0));
	vec2 clip = vec2(-viewSpaceMirrorPos.z + 0.0001, 64);
	vec2 size = mirrors[mirrorId].size;
	vec4 bounds = viewSpaceMirrorPos.xxyy + vec4(-size.x, size.x, -size.y, size.y) * 0.5;

	mirrorData.viewMat[index] = mirrorViewMat;
	mirrorData.projMat[index] = makeProjectionMatrix(viewSpaceMirrorPos, clip, size, bounds);
	mirrorData.invViewMat[index] = inverse(mirrorData.viewMat[index]);
	mirrorData.invProjMat[index] = inverse(mirrorData.projMat[index]);
	mirrorData.clip[index] = clip;
	mirrorData.nearInfo[index] = vec4(bounds.xz, size);
	mirrorData.lightDirection[index] = normalize(lightDir);
}