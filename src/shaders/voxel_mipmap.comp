#version 430

##import voxel_shared
##import lib/util
##import lib/types_common

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, r32ui) readonly uniform uimage2D previousMipList;
layout (binding = 1, r32ui) uniform uimage2D currentMipList;

layout (binding = 2, rgba16) readonly uniform image3D previousVoxelRadiance;
layout (binding = 3, rgba16) writeonly uniform image3D currentVoxelRadiance;

layout (binding = 0) uniform atomic_uint previousFragListSize;
layout (binding = 0, offset = 16) uniform atomic_uint nextFragListSize;
layout (binding = 0, offset = 20) uniform atomic_uint nextComputeSize;

layout(binding = 0, std140) uniform GLVoxelInfo {
	VoxelInfo voxelInfo;
};

uniform int mipLevel = 1;

#define MIPMAP_POSITION(mipPosition, map, level) ((mipPosition) + ivec3((map) * VOXEL_GRID_SIZE >> (level), 0, 0))

void main() {
	uint index = gl_WorkGroupID.x * (gl_WorkGroupSize.x * gl_WorkGroupSize.y) + gl_LocalInvocationIndex;
	uint size = atomicCounter(previousFragListSize);
	if (index >= size) return;

	uint packedPosition = imageLoad(previousMipList, ivec2(index & MaxFragListMask[mipLevel - 1], index >> FragListWidthBits[mipLevel - 1])).r;
	ivec3 position = ivec3(
		(packedPosition >> 20) & 0x3FF,
		(packedPosition >> 10) & 0x3FF,
		packedPosition & 0x3FF
	);
	ivec3 mipPosition = position >> 1;
	ivec3 floorPosition = mipPosition << 1;

	float alpha = 0.0;
	float count = 0.0;
	vec3[MAX_VOXEL_AREAS + 1] radiance;
	for (int i = 0; i < MAX_VOXEL_AREAS + 1; i++) radiance[i] = vec3(0);

	for (int x = 0; x < 2; x++) {
		for (int y = 0; y < 2; y++) {
			for (int z = 0; z < 2; z++) {
				// This invocation should only run if we're the first value in the group.
				if (position == floorPosition + ivec3(x, y, z) && count > 0) return;

				ivec3 samplePos = floorPosition + ivec3(x, y, z);
				vec4 sampleValue = imageLoad(previousVoxelRadiance, samplePos);

				radiance[0] += sampleValue.rgb;
				if (mipLevel == 1) {
					vec3 samplePosWorld = vec3(samplePos - VOXEL_GRID_SIZE * 0.5 + 0.5) * voxelInfo.size + voxelInfo.center;
					for (int i = 0; i < MAX_VOXEL_AREAS; i++) {
						bool inArea = samplePosWorld == clamp(samplePosWorld, voxelInfo.areas[i].areaMin, voxelInfo.areas[i].areaMax);
						radiance[i+1] += sampleValue.rgb * float(inArea);
					}
				} else {
					for (int i = 0; i < MAX_VOXEL_AREAS; i++) {
						radiance[i+1] += imageLoad(previousVoxelRadiance, MIPMAP_POSITION(samplePos, i + 1, mipLevel - 1)).rgb;
					}
				}
				alpha += sampleValue.a;

				count += 1 - step(0, -sampleValue.a);
			}
		}
	}

	// Bias alpha so that 50% full is opaque
	alpha = saturate(alpha * 0.25);

	// 0.25 looks good, don't touch it ¯\_(ツ)_/¯
	for (int i = 0; i < MAX_VOXEL_AREAS + 1; i++) {
		imageStore(currentVoxelRadiance, MIPMAP_POSITION(mipPosition, i, mipLevel), vec4(radiance[i] * 0.25, alpha));
	}

	uint nextIndex = atomicCounterIncrement(nextFragListSize);
	if (nextIndex % MipmapWorkGroupSize == 0) atomicCounterIncrement(nextComputeSize);

	uint packedData = (uint(mipPosition.x) & 0x3FF) << 20;
	packedData += (uint(mipPosition.y) & 0x3FF) << 10;
	packedData += uint(mipPosition.z) & 0x3FF;
	imageStore(currentMipList, ivec2(nextIndex & MaxFragListMask[mipLevel], nextIndex >> FragListWidthBits[mipLevel]), uvec4(packedData));
}
