#version 460

layout(local_size_x = 16, local_size_y = 16) in;

#include "../lib/types_common.glsl"
#include "../lib/voxel_shared.glsl"

layout(binding = 0) uniform VoxelStateUniform {
    VoxelState voxelInfo;
};

layout(binding = 1, rgba16f) writeonly uniform image3D radianceOut;

struct FragmentListMetadata {
    uint count;
    uint capacity;
    uint offset;
    VkDispatchIndirectCommand cmd;
};

layout(std430, binding = 2) buffer VoxelFragmentListMetadata {
    uint count;
    uint capacity;
    uint offset;
    VkDispatchIndirectCommand cmd;
};

layout(std430, binding = 3) buffer VoxelFragmentList {
    VoxelFragment fragmentLists[];
};

layout(set = 1, binding = 0) uniform sampler3D voxelLayersIn[6];

void main() {
    uint index = gl_WorkGroupID.x * (gl_WorkGroupSize.x * gl_WorkGroupSize.y) + gl_LocalInvocationIndex;
    if (index >= count) return;

    ivec3 position = ivec3(fragmentLists[index].position);
    vec3 radiance = vec3(fragmentLists[index].radiance);
    vec3 worldNormal = vec3(fragmentLists[index].normal);

    int axis = DominantAxis(worldNormal);
    if (axis < 0) {
        axis = -axis + 2;
    } else {
        axis -= 1;
    }
    // vec4 voxelValue = vec4(0);
    // for (int i = 0; i < 6; i++) {
    //     vec4 sampleValue = texelFetch(voxelLayersIn[i], position + ivec3(AxisDirections[i]), 0);
    //     voxelValue += sampleValue * step(0, dot(AxisDirections[i], worldNormal));
    // }
    // imageStore(radianceOut, position, voxelValue);
    vec4 voxelValue = texelFetch(voxelLayersIn[axis], position + ivec3(AxisDirections[axis]), 0);
    imageStore(radianceOut, position, voxelValue);

    // vec3 worldPosition = (inverse(voxelInfo.worldToVoxel) * vec4(position + 0.5f, 1.0)).xyz;

    // vec3 indirectDiffuse = HemisphereIndirectDiffuse(worldPosition, worldNormal, vec2(0));
    // vec3 samplePos = worldPosition;
    // vec3 sampleDir = OrientByNormal(0.0, 0.1, worldNormal);
    // vec4 indirectDiffuse = ConeTraceGridDiffuse(samplePos, worldNormal, 0);

    // for (int a = 3; a <= 6; a += 3) {
    //     float diffuseScale = 1.0 / a;
    //     for (float r = 0; r < a; r++) {
    //         vec3 sampleDir = OrientByNormal(r * diffuseScale * M_PI * 2.0, a * 0.1, worldNormal);
    //         vec4 sampleColor = ConeTraceGridDiffuse(samplePos, sampleDir, 0);

    //         indirectDiffuse += sampleColor * dot(sampleDir, worldNormal) * diffuseScale;
    //     }
    // }

    // imageStore(radianceOut, position, vec4(indirectDiffuse.rgb * 0.333, 1));
}
