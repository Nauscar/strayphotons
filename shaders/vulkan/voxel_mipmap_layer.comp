#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include "../lib/types_common.glsl"
#include "../lib/util.glsl"
#include "../lib/voxel_shared.glsl"

layout(binding = 0) uniform VoxelStateUniform {
    VoxelState voxelInfo;
};

layout(binding = 1) uniform LayerDataUniform {
    vec3 layerDirection;
    uint layerIndex;
};

layout(binding = 2, rgba16f) writeonly uniform image3D voxelLayerOut;

layout(binding = 3) uniform sampler3D voxelLayersIn[6];

const uint[6] OppositeAxis = uint[](3, 4, 5, 0, 1, 2);
const vec3[6] AxisDirections =
    vec3[](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1), vec3(-1, 0, 0), vec3(0, -1, 0), vec3(0, 0, -1));

void main() {
    ivec3 voxelPos = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(voxelPos, imageSize(voxelLayerOut)))) return;

    int axis = DominantAxis(layerDirection);
    if (axis < 0) {
        axis = -axis + 2;
    } else {
        axis -= 1;
    }
    uint inverseAxis = OppositeAxis[axis];

    int stride = 1 << max(0, layerIndex - 1);
    vec4 voxelValue = texelFetch(voxelLayersIn[axis], voxelPos, 0);

    vec4 sampleValue = texelFetch(voxelLayersIn[axis], voxelPos + ivec3(layerDirection) * stride, 0);
    sampleValue.a *= max(0, 1 - voxelValue.a);
    for (int a = 0; a < 6; a++) {
        if (a == axis || a == inverseAxis) continue;
        ivec3 sampleOffset = ivec3(AxisDirections[a]) * stride;
        float alpha = texelFetch(voxelLayersIn[a], voxelPos, 0).a;

        vec4 sampleValue2 = texelFetch(voxelLayersIn[axis], voxelPos + sampleOffset, 0);
        sampleValue2.a *= max(0, 1 - alpha);
        sampleValue += sampleValue2;
    }

    if (sampleValue.a > 0) {
        if (sampleValue.a > 1) sampleValue /= sampleValue.a;
        voxelValue.a += sampleValue.a;
        voxelValue.rgb = mix(voxelValue.rgb, sampleValue.rgb, sampleValue.a / voxelValue.a);
    }

    imageStore(voxelLayerOut, ivec3(voxelPos), voxelValue);
}
