#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include "../lib/types_common.glsl"
#include "../lib/util.glsl"
#include "../lib/voxel_shared.glsl"

layout(binding = 0) uniform LayerDataUniform {
    vec3 layerDirection;
    uint layerIndex;
};

layout(binding = 1) uniform sampler3D voxelLayerIn;
layout(binding = 2, rgba16f) writeonly uniform image3D voxelLayerOut;

// Sigma = 0.5
const float[3][3] GaussianKernel = float[][](float[](0.0249, 0.1080, 0.0249),
    float[](0.1080, 0.4686, 0.1080),
    float[](0.0249, 0.1080, 0.0249));

void main() {
    ivec3 voxelPos = ivec3(gl_GlobalInvocationID);
    if (any(greaterThanEqual(voxelPos, imageSize(voxelLayerOut)))) return;

    if (layerIndex == 0) {
        imageStore(voxelLayerOut, ivec3(voxelPos), texelFetch(voxelLayerIn, voxelPos, 0));
        return;
    }

    int stride = max(1, int(layerIndex) - 1);

    int axis = DominantAxis(layerDirection);
    if (axis < 0) {
        axis = -axis + 2;
    } else {
        axis -= 1;
    }
    ivec3 tangentAxisA = ivec3(AxisDirections[TangentAxisA[axis]]) * stride;
    ivec3 tangentAxisB = ivec3(AxisDirections[TangentAxisB[axis]]) * stride;

    vec4 sampleValue = vec4(0);
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            ivec3 samplePos = voxelPos + tangentAxisA * i + tangentAxisB * j;
            float dist = length(vec3(tangentAxisA * i + tangentAxisB * j));
            sampleValue += texelFetch(voxelLayerIn, samplePos, 0) * GaussianKernel[i + 1][j + 1];
        }
    }
    imageStore(voxelLayerOut, ivec3(voxelPos), sampleValue);
}
